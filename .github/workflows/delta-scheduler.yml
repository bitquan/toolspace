name: OPS-Delta Scheduler

on:
    schedule:
        - cron: "0 14 * * *" # Daily at 2 PM UTC
    workflow_dispatch:
        inputs:
            dry_run:
                description: "Dry run (true/false)"
                required: true
                default: "true"
                type: string

permissions:
    contents: write
    issues: write
    pull-requests: write

jobs:
    schedule:
        runs-on: ubuntu-latest

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: OPS-Delta Sprint Scheduler
              uses: actions/github-script@v7
              with:
                  script: |
                      const dry = (core.getInput('dry_run') || '${{ github.event.inputs.dry_run }}' || 'true').toLowerCase() === 'true';

                      // Import dayjs for ISO week calculations
                      const dayjs = require('dayjs');
                      const isoWeek = require('dayjs/plugin/isoWeek');
                      dayjs.extend(isoWeek);

                      function sprintName(d = new Date()) {
                        const y = d.getFullYear().toString().slice(-2);
                        const month = String(d.getMonth() + 1).padStart(2, '0');
                        const w = String(dayjs(d).isoWeek()).padStart(2, '0');
                        return `Sprint-${y}${month}-W${w}`;
                      }

                      const sprint = sprintName();
                      core.info(`ðŸš€ OPS-Delta Scheduler Starting`);
                      core.info(`Sprint: ${sprint}`);
                      core.info(`Dry Run: ${dry}`);

                      // Ensure current sprint milestone exists
                      const { data: milestones } = await github.rest.issues.listMilestones({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        state: 'open'
                      });

                      let milestone = milestones.find(x => x.title === sprint);
                      if (!milestone && !dry) {
                        const { data } = await github.rest.issues.createMilestone({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          title: sprint,
                          state: 'open',
                          description: `Adaptive sprint managed by OPS-Delta`
                        });
                        milestone = data;
                        core.info(`âœ… Created milestone: ${sprint}`);
                      }

                      // Helper function to fetch issues by priority label
                      async function findByPriority(label) {
                        const { data: issues } = await github.rest.issues.listForRepo({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          state: 'open',
                          labels: label,
                          per_page: 100
                        });
                        return issues.filter(i => !i.labels.some(l => l.name === 'ready') && !i.pull_request);
                      }

                      // Build backlog prioritized by P0-blocker > P1 > P2
                      let backlog = [];
                      for (const priority of ['P0-blocker', 'P1', 'P2']) {
                        backlog = backlog.concat(await findByPriority(priority));
                      }

                      // Naive estimate parser from body or labels
                      const parseEstimate = (issue) => {
                        const bodyMatch = (issue.body || '').match(/estimate:\s*([\d\.]+)\s*d/i);
                        if (bodyMatch) return parseFloat(bodyMatch[1]);

                        const labelMatch = (issue.labels || []).map(l => l.name).join(' ').match(/est:([\d\.]+)d/i);
                        if (labelMatch) return parseFloat(labelMatch[1]);

                        return 1.0; // default
                      };

                      // Sort backlog by priority then estimate (shortest first)
                      function getPriority(issue) {
                        if (issue.labels.some(l => l.name === 'P0-blocker')) return 0;
                        if (issue.labels.some(l => l.name === 'P1')) return 1;
                        return 2;
                      }

                      backlog.sort((a, b) => {
                        const priorityDiff = getPriority(a) - getPriority(b);
                        if (priorityDiff !== 0) return priorityDiff;
                        return parseEstimate(a) - parseEstimate(b);
                      });

                      // Check current ready queue size
                      const { data: currentReady } = await github.rest.issues.listForRepo({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        state: 'open',
                        labels: 'ready',
                        per_page: 100
                      });

                      let readyCount = currentReady.filter(x => !x.pull_request).length;
                      const targetReady = 5;
                      const selectedIssues = [];

                      // Add ready labels to top backlog items until we reach target of 5
                      for (const issue of backlog) {
                        if (readyCount >= targetReady) break;

                        if (dry) {
                          core.info(`[DRY] Would label #${issue.number} ready and add to milestone ${sprint}`);
                          selectedIssues.push(issue);
                          readyCount++;
                          continue;
                        }

                        // Add ready label
                        await github.rest.issues.addLabels({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issue.number,
                          labels: ['ready']
                        });

                        // Add to milestone if it exists
                        if (milestone) {
                          await github.rest.issues.update({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issue.number,
                            milestone: milestone.number
                          });
                        }

                        core.info(`âœ… Added #${issue.number} to ready queue and ${sprint} milestone`);
                        selectedIssues.push(issue);
                        readyCount++;
                      }

                      // Remove ready from overflow items (if any exist beyond target)
                      const overflowReady = currentReady.filter(x => !x.pull_request).slice(targetReady);
                      for (const issue of overflowReady) {
                        if (dry) {
                          core.info(`[DRY] Would remove ready label from overflow issue #${issue.number}`);
                          continue;
                        }

                        await github.rest.issues.removeLabel({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issue.number,
                          name: 'ready'
                        });

                        core.info(`â¸ï¸ Removed ready label from overflow issue #${issue.number}`);
                      }

                      // Write audit log to Sprint Epic (if it exists)
                      const epicIssues = await github.rest.issues.listForRepo({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        state: 'open',
                        labels: 'epic',
                        per_page: 100
                      });

                      const sprintEpic = epicIssues.data.find(epic =>
                        epic.title.toLowerCase().includes(sprint.toLowerCase()) ||
                        epic.title.toLowerCase().includes('sprint')
                      );

                      if (sprintEpic && !dry) {
                        const auditLog = `ðŸ¤– **Delta Scheduler Audit - ${new Date().toISOString().split('T')[0]}**\n\n` +
                                       `- Ready queue maintained at ${readyCount}/${targetReady} issues\n` +
                                       `- Added ${selectedIssues.length} new issues to ready queue\n` +
                                       `- Removed ${overflowReady.length} overflow issues from queue\n` +
                                       `- Sprint: ${sprint}\n\n` +
                                       selectedIssues.map(i => `  - #${i.number} ${i.title}`).join('\n');

                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: sprintEpic.number,
                          body: auditLog
                        });
                      }

                      // Generate summary
                      core.summary.addHeading('OPS-Delta Scheduler Results', 2);
                      core.summary.addTable([
                        ['Metric', 'Value'],
                        ['Sprint', sprint],
                        ['Mode', dry ? 'Dry Run' : 'Live'],
                        ['Ready Queue Size', `${readyCount}/${targetReady}`],
                        ['Issues Added to Queue', selectedIssues.length.toString()],
                        ['Overflow Issues Removed', overflowReady.length.toString()],
                        ['Backlog Candidates', backlog.length.toString()]
                      ]);

                      if (selectedIssues.length > 0) {
                        core.summary.addHeading('Issues Added to Ready Queue', 3);
                        const issueTable = [['Issue', 'Priority', 'Estimate']];
                        selectedIssues.forEach(issue => {
                          const priority = issue.labels.find(l => l.name.match(/^P[0-2]/))?.name || 'P2';
                          const estimate = parseEstimate(issue);
                          issueTable.push([
                            `#${issue.number} ${issue.title}`,
                            priority,
                            `${estimate}d`
                          ]);
                        });
                        core.summary.addTable(issueTable);
                      }

                      await core.summary.write();
                      core.info(`ðŸŽ¯ Sprint scheduler complete - Ready queue: ${readyCount}/${targetReady}`);

            - name: Trigger roadmap sync
              if: ${{ github.event.inputs.dry_run != 'true' }}
              uses: actions/github-script@v7
              with:
                  script: |
                      try {
                        await github.rest.actions.createWorkflowDispatch({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          workflow_id: 'roadmap-to-issues.yml',
                          ref: 'main',
                          inputs: {
                            dry_run: 'false',
                            path: 'docs/roadmap/phase-1.md'
                          }
                        });
                        core.info('âœ… Triggered roadmap sync');
                      } catch (error) {
                        core.info(`Could not trigger roadmap sync: ${error.message}`);
                      }

            - name: Send scheduler notification
              if: github.event_name == 'schedule' && github.event.inputs.dry_run != 'true'
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  echo "Sending sprint scheduler notification..."
                  gh workflow run delta-notify.yml \
                    -f event_type="sprint_scheduled" \
                    -f title="ðŸ“… Sprint Scheduling Complete" \
                    -f message="Daily sprint scheduling has completed. Ready queue has been updated with prioritized issues." \
                    -f severity="info" \
                    -f dry_run="false"
