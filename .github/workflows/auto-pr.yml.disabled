name: Auto PR

on:
  push:
    branches:
      - "feat/**"
      - "fix/**"
      - "chore/**"
      - "docs/**"

permissions:
  contents: read
  pull-requests: write
  issues: read

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  verify-local-gate:
    name: ðŸ”’ Verify Local Gate
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request_target'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Check local preflight artifacts
        run: |
          echo "ðŸ”’ Checking local preflight artifacts..."

          if [ ! -f "local-ci/pr-ci-summary.json" ]; then
            echo "âŒ ERROR: local-ci/pr-ci-summary.json not found!"
            echo ""
            echo "This means preflight was not run before push."
            echo "The local gate should have blocked this push."
            echo ""
            echo "To fix:"
            echo "  1. Run: npm run preflight"
            echo "  2. Verify all checks pass"
            echo "  3. Push again"
            exit 1
          fi

          echo "âœ“ pr-ci-summary.json found"
          cat local-ci/pr-ci-summary.json

      - name: âœ… Verify preflight passed
        run: |
          SUCCESS=$(jq -r '.summary.success' local-ci/pr-ci-summary.json)

          if [ "$SUCCESS" != "true" ]; then
            echo "âŒ ERROR: Local preflight did not pass!"
            echo ""
            jq '.summary' local-ci/pr-ci-summary.json
            echo ""
            echo "Fix all preflight errors before pushing."
            exit 1
          fi

          echo "âœ… Local preflight passed!"
          jq '.summary' local-ci/pr-ci-summary.json

  check-ci-status:
    name: Check CI Status
    runs-on: ubuntu-latest
    needs: verify-local-gate
    outputs:
      should_create_pr: ${{ steps.check.outputs.should_create }}
      issue_number: ${{ steps.extract.outputs.issue_number }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract issue number from branch
        id: extract
        run: |
          branch="${{ github.ref_name }}"
          echo "Branch: $branch"

          # Extract issue number from branch name (feat/issue-123-description)
          if [[ "$branch" =~ ^(feat|fix|chore|docs)/issue-([0-9]+)- ]]; then
            issue_number="${BASH_REMATCH[2]}"
            echo "issue_number=$issue_number" >> $GITHUB_OUTPUT
            echo "Found issue number: $issue_number"
          else
            echo "No issue number found in branch name"
            echo "issue_number=" >> $GITHUB_OUTPUT
          fi

      - name: Check if PR already exists
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const branch = context.ref.replace('refs/heads/', '');
            const issueNumber = '${{ steps.extract.outputs.issue_number }}';

            console.log(`Checking for existing PR from branch: ${branch}`);

            // Check if PR already exists for this branch
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open'
            });

            if (prs.data.length > 0) {
              console.log(`PR already exists: #${prs.data[0].number}`);
              core.setOutput('should_create', 'false');
              return;
            }

            // Wait for CI to complete
            console.log('Checking CI status...');

            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha
            });

            const workflowRuns = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: context.sha
            });

            // Look for Branch CI workflow
            const branchCIRuns = workflowRuns.data.workflow_runs.filter(run =>
              run.name === 'Branch CI' && run.head_sha === context.sha
            );

            if (branchCIRuns.length === 0) {
              console.log('No Branch CI run found yet, will wait');
              core.setOutput('should_create', 'false');
              return;
            }

            const latestRun = branchCIRuns[0];
            console.log(`Latest Branch CI run: ${latestRun.status} - ${latestRun.conclusion}`);

            if (latestRun.status !== 'completed') {
              console.log('CI is still running, will wait');
              core.setOutput('should_create', 'false');
              return;
            }

            if (latestRun.conclusion !== 'success') {
              console.log(`CI failed with conclusion: ${latestRun.conclusion}`);
              core.setOutput('should_create', 'false');
              return;
            }

            console.log('âœ… CI passed, ready to create PR');
            core.setOutput('should_create', 'true');

  create-pr:
    name: Create Pull Request
    needs: [check-ci-status]
    if: needs.check-ci-status.outputs.should_create_pr == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get commit info and create PR
        uses: actions/github-script@v7
        with:
          script: |
            const branch = context.ref.replace('refs/heads/', '');
            const issueNumber = '${{ needs.check-ci-status.outputs.issue_number }}';

            console.log(`Creating PR for branch: ${branch}`);
            console.log(`Linked issue: #${issueNumber}`);

            // Get commits for this branch
            const commits = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: 'main',
              head: branch
            });

            // Get issue details if we have an issue number
            let issueTitle = '';
            let issueBody = '';
            let issueLabels = [];

            if (issueNumber) {
              try {
                const issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber)
                });

                issueTitle = issue.data.title;
                issueBody = issue.data.body || '';
                issueLabels = issue.data.labels.map(l => l.name);

                console.log(`Found issue: ${issueTitle}`);
              } catch (error) {
                console.log(`Could not fetch issue #${issueNumber}: ${error.message}`);
              }
            }

            // Generate PR title
            let prTitle;
            if (issueTitle) {
              prTitle = issueTitle;
            } else {
              // Extract from branch name
              const branchParts = branch.split('-');
              if (branchParts.length > 2) {
                prTitle = branchParts.slice(2).join(' ').replace(/\b\w/g, l => l.toUpperCase());
              } else {
                prTitle = `Changes from ${branch}`;
              }
            }

            // Generate PR body
            const commitList = commits.data.commits
              .map(commit => `- ${commit.commit.message.split('\n')[0]} (${commit.sha.substring(0, 7)})`)
              .join('\n');

            let prBody = '';

            if (issueNumber) {
              prBody += `## Related Issue\nCloses #${issueNumber}\n\n`;
            }

            if (issueBody) {
              prBody += `## Description\n${issueBody}\n\n`;
            }

            prBody += `## Changes\n${commitList}\n\n`;

            prBody += `## Checklist\n`;
            prBody += `- [x] Code follows project conventions\n`;
            prBody += `- [x] Tests pass locally\n`;
            prBody += `- [x] CI checks pass\n`;
            prBody += `- [ ] Code reviewed\n`;
            prBody += `- [ ] Documentation updated (if needed)\n\n`;

            prBody += `---\n*Auto-generated from branch: \`${branch}\`*`;

            // Create the PR
            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: prTitle,
              body: prBody,
              head: branch,
              base: 'main'
            });

            console.log(`âœ… Created PR #${pr.data.number}: ${prTitle}`);

            // Add labels based on branch type and issue labels
            const prLabels = [];

            // Add branch type label
            if (branch.startsWith('feat/')) prLabels.push('type: feature');
            if (branch.startsWith('fix/')) prLabels.push('type: fix');
            if (branch.startsWith('chore/')) prLabels.push('type: chore');
            if (branch.startsWith('docs/')) prLabels.push('type: documentation');

            // Add issue labels if available
            prLabels.push(...issueLabels.filter(label =>
              !label.includes('status:') && // Don't copy status labels
              !label.includes('ready')     // Don't copy ready label
            ));

            // Add auto-pr label
            prLabels.push('auto-generated');

            if (prLabels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.data.number,
                labels: prLabels
              });

              console.log(`Added labels: ${prLabels.join(', ')}`);
            }

            // Assign reviewer (could be made configurable)
            try {
              await github.rest.pulls.requestReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.data.number,
                reviewers: ['bitquan'] // Make this configurable
              });

              console.log('Requested review from bitquan');
            } catch (error) {
              console.log(`Could not assign reviewer: ${error.message}`);
            }

            // Update the issue if we have one
            if (issueNumber) {
              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  body: `ðŸ”„ **Pull Request Created**: #${pr.data.number}\n\n` +
                        `Ready for review! The CI checks have passed and this PR is ready to be reviewed.\n\n` +
                        `**PR**: [${prTitle}](${pr.data.html_url})\n` +
                        `**Branch**: \`${branch}\`\n\n` +
                        `Once approved and merged, this issue will be automatically closed.`
                });

                // Update issue status
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber),
                  labels: ['status: review']
                });

                // Remove in-progress label
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parseInt(issueNumber),
                    name: 'status: in-progress'
                  });
                } catch (error) {
                  console.log('Could not remove in-progress label');
                }

              } catch (error) {
                console.log(`Could not update issue: ${error.message}`);
              }
            }

            // Output PR details
            core.summary.addHeading('Pull Request Created', 2);
            core.summary.addTable([
              ['Property', 'Value'],
              ['PR Number', `#${pr.data.number}`],
              ['Title', prTitle],
              ['Branch', branch],
              ['Issue', issueNumber ? `#${issueNumber}` : 'None'],
              ['Labels', prLabels.join(', ')],
              ['URL', pr.data.html_url]
            ]);
            await core.summary.write();
