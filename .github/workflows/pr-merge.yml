name: PR Auto-Merge

on:
    pull_request:
        types: [opened, synchronize, reopened]
    pull_request_review:
        types: [submitted]
    check_suite:
        types: [completed]
    workflow_run:
        workflows: ["CI", "Branch CI"]
        types: [completed]

permissions:
    contents: write
    pull-requests: write
    issues: write
    checks: read

jobs:
    check-merge-conditions:
        name: Check Merge Conditions
        runs-on: ubuntu-latest
        if: github.event.pull_request.draft == false
        outputs:
            should_merge: ${{ steps.check.outputs.should_merge }}
            pr_number: ${{ steps.check.outputs.pr_number }}
            issue_number: ${{ steps.check.outputs.issue_number }}

        steps:
            - name: Get PR details
              id: check
              uses: actions/github-script@v7
              with:
                  script: |
                      let prNumber;

                      // Get PR number from different event types
                      if (context.eventName === 'pull_request' || context.eventName === 'pull_request_review') {
                        prNumber = context.payload.pull_request.number;
                      } else if (context.eventName === 'workflow_run' || context.eventName === 'check_suite') {
                        // Find PR associated with this commit
                        const prs = await github.rest.pulls.list({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          state: 'open',
                          head: context.payload.workflow_run?.head_branch || context.payload.check_suite?.head_branch
                        });
                        
                        if (prs.data.length === 0) {
                          console.log('No open PR found for this workflow run');
                          core.setOutput('should_merge', 'false');
                          return;
                        }
                        
                        prNumber = prs.data[0].number;
                      } else {
                        console.log(`Unsupported event type: ${context.eventName}`);
                        core.setOutput('should_merge', 'false');
                        return;
                      }

                      core.setOutput('pr_number', prNumber);

                      console.log(`Checking merge conditions for PR #${prNumber}`);

                      // Get PR details
                      const pr = await github.rest.pulls.get({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: prNumber
                      });

                      console.log(`PR: ${pr.data.title}`);
                      console.log(`Branch: ${pr.data.head.ref}`);
                      console.log(`Draft: ${pr.data.draft}`);
                      console.log(`Mergeable: ${pr.data.mergeable}`);

                      // Skip if draft
                      if (pr.data.draft) {
                        console.log('PR is draft, skipping auto-merge');
                        core.setOutput('should_merge', 'false');
                        return;
                      }

                      // Extract issue number from PR body or branch
                      let issueNumber = null;

                      // Check PR body for "Closes #123" pattern
                      const bodyMatch = pr.data.body?.match(/(?:close[sd]?|fix(?:ed|es)?|resolve[sd]?)\s+#(\d+)/i);
                      if (bodyMatch) {
                        issueNumber = bodyMatch[1];
                      } else {
                        // Check branch name for issue number
                        const branchMatch = pr.data.head.ref.match(/issue-(\d+)/);
                        if (branchMatch) {
                          issueNumber = branchMatch[1];
                        }
                      }

                      core.setOutput('issue_number', issueNumber || '');
                      console.log(`Linked issue: ${issueNumber ? '#' + issueNumber : 'None'}`);

                      // Check if PR has auto-merge label or is auto-generated
                      const labels = pr.data.labels.map(l => l.name);
                      const hasAutoMergeLabel = labels.includes('auto-merge') || labels.includes('auto-generated');

                      if (!hasAutoMergeLabel) {
                        console.log('PR does not have auto-merge label, skipping');
                        core.setOutput('should_merge', 'false');
                        return;
                      }

                      // Check reviews
                      const reviews = await github.rest.pulls.listReviews({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: prNumber
                      });

                      const latestReviews = {};
                      reviews.data.forEach(review => {
                        latestReviews[review.user.login] = review.state;
                      });

                      const approvals = Object.values(latestReviews).filter(state => state === 'APPROVED').length;
                      const rejections = Object.values(latestReviews).filter(state => state === 'CHANGES_REQUESTED').length;

                      console.log(`Reviews - Approvals: ${approvals}, Changes requested: ${rejections}`);

                      if (rejections > 0) {
                        console.log('PR has requested changes, cannot auto-merge');
                        core.setOutput('should_merge', 'false');
                        return;
                      }

                      if (approvals === 0) {
                        console.log('PR has no approvals yet, cannot auto-merge');
                        core.setOutput('should_merge', 'false');
                        return;
                      }

                      // Check CI status
                      const checks = await github.rest.checks.listForRef({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        ref: pr.data.head.sha
                      });

                      const workflowRuns = await github.rest.actions.listWorkflowRunsForRepo({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        head_sha: pr.data.head.sha
                      });

                      // Check for required CI workflows
                      const requiredWorkflows = ['CI', 'Branch CI'];
                      const workflowStatus = {};

                      for (const workflowName of requiredWorkflows) {
                        const runs = workflowRuns.data.workflow_runs.filter(run => 
                          run.name === workflowName && run.head_sha === pr.data.head.sha
                        );
                        
                        if (runs.length === 0) {
                          workflowStatus[workflowName] = 'missing';
                        } else {
                          const latestRun = runs[0];
                          workflowStatus[workflowName] = {
                            status: latestRun.status,
                            conclusion: latestRun.conclusion
                          };
                        }
                      }

                      console.log('Workflow status:', JSON.stringify(workflowStatus, null, 2));

                      // Check if all required workflows passed
                      for (const [workflow, status] of Object.entries(workflowStatus)) {
                        if (status === 'missing') {
                          console.log(`Required workflow '${workflow}' has not run`);
                          core.setOutput('should_merge', 'false');
                          return;
                        }
                        
                        if (status.status !== 'completed' || status.conclusion !== 'success') {
                          console.log(`Workflow '${workflow}' did not pass: ${status.status} - ${status.conclusion}`);
                          core.setOutput('should_merge', 'false');
                          return;
                        }
                      }

                      // Check mergeable state
                      if (pr.data.mergeable === false) {
                        console.log('PR has merge conflicts');
                        core.setOutput('should_merge', 'false');
                        return;
                      }

                      console.log('‚úÖ All conditions met, ready to merge');
                      core.setOutput('should_merge', 'true');

    merge-pr:
        name: Merge Pull Request
        needs: [check-merge-conditions]
        if: needs.check-merge-conditions.outputs.should_merge == 'true'
        runs-on: ubuntu-latest

        steps:
            - name: Merge PR and update issue
              uses: actions/github-script@v7
              with:
                  script: |
                      const prNumber = parseInt('${{ needs.check-merge-conditions.outputs.pr_number }}');
                      const issueNumber = '${{ needs.check-merge-conditions.outputs.issue_number }}';

                      console.log(`Merging PR #${prNumber}`);

                      // Get PR details for merge commit message
                      const pr = await github.rest.pulls.get({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: prNumber
                      });

                      // Merge the PR
                      const mergeResult = await github.rest.pulls.merge({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: prNumber,
                        commit_title: `${pr.data.title} (#${prNumber})`,
                        commit_message: `Auto-merged after CI passed and review approved\n\n${pr.data.body || ''}`,
                        merge_method: 'squash' // Use squash merge to keep history clean
                      });

                      console.log(`‚úÖ PR merged: ${mergeResult.data.sha}`);

                      // Update linked issue if exists
                      if (issueNumber) {
                        try {
                          // Remove work-in-progress labels
                          const currentIssue = await github.rest.issues.get({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: parseInt(issueNumber)
                          });
                          
                          const labelsToRemove = ['ready', 'autodev', 'in-progress', 'status:in-progress'];
                          const currentLabels = currentIssue.data.labels.map(l => l.name);
                          
                          for (const labelToRemove of labelsToRemove) {
                            if (currentLabels.includes(labelToRemove)) {
                              try {
                                await github.rest.issues.removeLabel({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: parseInt(issueNumber),
                                  name: labelToRemove
                                });
                                console.log(`Removed label: ${labelToRemove}`);
                              } catch (labelError) {
                                console.log(`Could not remove label ${labelToRemove}: ${labelError.message}`);
                              }
                            }
                          }
                          
                          // Close the issue
                          await github.rest.issues.update({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: parseInt(issueNumber),
                            state: 'closed',
                            state_reason: 'completed'
                          });
                          
                          // Add completion comment
                          await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: parseInt(issueNumber),
                            body: `üéâ **Issue Completed Successfully**\n\n` +
                                  `‚úÖ **Implementation**: Merged via PR #${prNumber}\n` +
                                  `‚úÖ **Merge commit**: \`${mergeResult.data.sha}\`\n` +
                                  `‚úÖ **Completed at**: ${new Date().toISOString()}\n` +
                                  `‚úÖ **Branches cleaned**: All related branches deleted\n\n` +
                                  `**AUTO-DEV Pipeline Complete** - Changes are now live on main branch!\n\n` +
                                  `*Automated by PR Auto-Merge workflow*`
                          });
                          
                          // Add completion labels
                          await github.rest.issues.addLabels({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: parseInt(issueNumber),
                            labels: ['status:completed', 'auto-merged']
                          });
                          
                          console.log(`‚úÖ Issue #${issueNumber} closed and cleaned up`);
                          
                        } catch (error) {
                          console.log(`Could not update issue #${issueNumber}: ${error.message}`);
                        }
                      }

                      // Clean up branches
                      try {
                        const branchName = pr.data.head.ref;
                        
                        // Delete the PR branch
                        await github.rest.git.deleteRef({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          ref: `heads/${branchName}`
                        });
                        
                        console.log(`‚úÖ Deleted PR branch: ${branchName}`);
                        
                        // Also delete related bot branches if they exist
                        if (issueNumber) {
                          const relatedBranches = [
                            `bot/issue-${issueNumber}-autodev`,
                            `feat/issue-${issueNumber}-*`,
                            `feature/issue-${issueNumber}*`
                          ];
                          
                          // Get all branches
                          const allBranches = await github.rest.repos.listBranches({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            per_page: 100
                          });
                          
                          // Find and delete related branches
                          for (const branch of allBranches.data) {
                            const shouldDelete = relatedBranches.some(pattern => {
                              if (pattern.includes('*')) {
                                const regex = new RegExp(pattern.replace(/\*/g, '.*'));
                                return regex.test(branch.name);
                              }
                              return branch.name === pattern;
                            });
                            
                            if (shouldDelete && branch.name !== branchName) {
                              try {
                                await github.rest.git.deleteRef({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  ref: `heads/${branch.name}`
                                });
                                console.log(`‚úÖ Deleted related branch: ${branch.name}`);
                              } catch (deleteError) {
                                console.log(`Could not delete branch ${branch.name}: ${deleteError.message}`);
                              }
                            }
                          }
                        }
                        
                      } catch (error) {
                        console.log(`Could not delete branches: ${error.message}`);
                      }

                      // Generate summary
                      core.summary.addHeading('üéâ Auto-Merge & Cleanup Completed', 2);
                      core.summary.addTable([
                        ['Property', 'Value'],
                        ['PR Number', `#${prNumber}`],
                        ['Issue Number', issueNumber ? `#${issueNumber}` : 'None'],
                        ['Merge SHA', `\`${mergeResult.data.sha}\``],
                        ['Primary Branch', `\`${pr.data.head.ref}\` ‚úÖ Deleted`],
                        ['Related Branches', issueNumber ? `bot/issue-${issueNumber}-* ‚úÖ Cleaned` : 'None'],
                        ['Issue Status', issueNumber ? '‚úÖ Closed & Labeled' : 'N/A'],
                        ['Labels Removed', issueNumber ? 'ready, autodev, in-progress' : 'N/A'],
                        ['Labels Added', issueNumber ? 'status:completed, auto-merged' : 'N/A'],
                        ['Merged At', new Date().toISOString()]
                      ]);
                      
                      core.summary.addRaw('\n\n### üßπ Cleanup Actions Performed:\n');
                      core.summary.addList([
                        '‚úÖ PR merged with squash commit',
                        '‚úÖ Primary branch deleted',
                        issueNumber ? '‚úÖ Related bot/feature branches cleaned' : '‚è≠Ô∏è No related branches to clean',
                        issueNumber ? '‚úÖ Issue closed and labeled' : '‚è≠Ô∏è No linked issue',
                        issueNumber ? '‚úÖ Work-in-progress labels removed' : '‚è≠Ô∏è No labels to remove',
                        '‚úÖ Completion comment added',
                        '‚úÖ Dev-log update triggered'
                      ]);
                      
                      await core.summary.write();

    trigger-post-merge:
        name: Trigger Post-Merge Actions
        needs: [check-merge-conditions, merge-pr]
        if: always() && needs.merge-pr.result == 'success'
        runs-on: ubuntu-latest

        steps:
            - name: Trigger dev-log update
              uses: actions/github-script@v7
              with:
                  script: |
                      // Trigger the dev-log updater workflow
                      await github.rest.actions.createWorkflowDispatch({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        workflow_id: 'dev-log-updater.yml',
                        ref: 'main',
                        inputs: {
                          pr_number: '${{ needs.check-merge-conditions.outputs.pr_number }}',
                          issue_number: '${{ needs.check-merge-conditions.outputs.issue_number }}'
                        }
                      });

                      console.log('‚úÖ Triggered dev-log updater workflow');
